syntax = 'proto3';

enum Command {
    CMD_STATUS = 0;
    CMD_CONFIG = 1;
    CMD_AUTOCALIBRATE = 2;
    CMD_START_SAMPLING = 3;
    CMD_STOP_SAMPLING = 4;
}

message ChannelConfig {
    uint32 samplerate = 1;
    uint32 channelmask = 2;
}

enum TriggerType {
    TRIGGER_LOW = 0;
    TRIGGER_HIGH = 1;
    TRIGGER_RISE = 2;
    TRIGGER_FALL = 3;
    TRIGGER_EDGE = 4;
}

message TriggerChannel {
    uint32 channel = 1;
    TriggerType type = 2;
}

message TriggerConfig {
    // Sigrok-style trigger matching, all trigger channels have to match.
    repeated TriggerChannel triggers = 1;
}

enum WaveType {
    WAVE_DC = 0;
    WAVE_SIN = 1;
    WAVE_RECTANGLE = 2;
    WAVE_TRIANGLE = 3;
}

enum SweepType {
    SWEEP_NONE = 0;
    SWEEP_LIN = 1;
    SWEEP_LOG = 2;
}

message WaveConfig {
    float hz = 1;
    float amplitude = 2;
    float offset = 3;
    float duty = 4; // For WAVE_RECTANGLE and WAVE_TRIANGLE only
}

message DACConfig {
    WaveType wave = 1;
    SweepType sweep = 2;
    float sweep_time = 3; // Sweep length in seconds
    WaveConfig start = 4; // Wave parameters at start of sweep
    WaveConfig end = 5; // Wave parameters at end of sweep (optional)
}

message Config {
    ChannelConfig digital = 16; // Digital inputs
    ChannelConfig analog1 = 17; // Voltage input 1
    ChannelConfig analog2 = 18; // Voltage input 2
    ChannelConfig analog3 = 19; // Current input
    ChannelConfig usb = 20; // USB protocol analyzer
    DACConfig dac1 = 21; // Analog output
}

message USBRequest {
    Command cmd = 1;
    Config cfg = 2;
}

enum Status {
    STATUS_UNKNOWN = 0;
    STATUS_IDLE = 1; // No measurement running
    STATUS_WAITTRIG = 2; // Waiting for trigger to occur
    STATUS_MEASURING = 3; // Measurement is running
    STATUS_STOPPING = 4; // Measurement has ended, sending rest of the data
    STATUS_ERROR = 5; // Unrecoverable error has occurred
}

enum ErrorCode {
    ERR_NONE = 0; // No error
    ERR_BUFFER_FULL = 1; // Buffers filled up during measurement
    ERR_VREF_OUT_OF_RANGE = 2; // Internal VREF+ out of range
    ERR_GND_REF_OUT_OF_RANGE = 3; // Virtual ground voltage out of range
}

enum ChannelId {
    CHANNEL_DIGITAL = 0;
    CHANNEL_ANALOG_V1 = 8;
    CHANNEL_ANALOG_V2 = 9;
    CHANNEL_ANALOG_I1 = 10;
    CHANNEL_USB = 16;
}

enum Compression {
    COMPRESSION_NONE = 0;
    COMPRESSION_SNAPPY = 1;
    COMPRESSION_DELTA_SNAPPY = 2;
}

enum Unit {
    UNIT_Volt = 0;
    UNIT_Ampere = 1;
}

message AnalogScale {
    float scaling = 1; // Samples are multiplied by this value
    Unit unit = 2; // Unit of the analog channel
}

message USBResponse {
    Status status = 1; // Current state of the device
    string statusmsg = 2; // Optional status message for user
    uint32 cpu_usage = 3; // Current CPU usage 0-100%
    
    // The fields below are present only when measurement is running.
    ChannelId channelidx = 8; // Identifies the channel the data is from
    uint32 samplerate = 9; // Actual samplerate of this channel
    int64 sampleidx = 10; // Running index of the first sample in this packet
    uint32 bits_per_sample = 11; // Number of uncompressed bits in each sample
    AnalogScale scaling = 12; // Scaling info, if this channel is analog
    Compression compression = 13; // Compression mode

    // Measurement data, little-endian, possibly deflate-compressed.
    // If bits_per_sample is not divisible by 8, samples are packed starting
    // at the least significant bit.
    // For analog channels, the first sample is the initial value, while every
    // sample after that is a mod-N delta from the previous sample. E.g. for
    // 16-bit samples, the delta should be added with wrapping 16-bit addition.
    bytes data = 20;

    // Padding inserted to align messages
    bytes padding = 31;
}

